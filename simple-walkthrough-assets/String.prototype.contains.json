{
  "title": "String.prototype.contains",
  "description": "Determine if a substring exists in a string.",
  "code": "// We often want to know if a string contains\n// a substring. In older versions of\n// ECMAscript, we had to use the \"indexOf\"\n// method. But, that returns a -1 when not\n// found which, according to the implicit type\n// conversions in ECMAscript, means true. So,\n// we had to do a comparison to determine the\n// truthiness of a substring in a string.\nvar s = 'There is nothing to fear but me.';\nvar search = {\n  good: 'nothing',\n  bad: 'marsha'\n};\n\nconsole.log(s.indexOf(search.good) > -1);\nconsole.log(s.indexOf(search.bad) > -1);\n\n// As a convenience, ECMAscript 6 provides the\n// String.prototype.contains method to return\n// a Boolean value rather than an integer.\nconsole.log(s.contains(search.good));\nconsole.log(s.contains(search.bad));\n\n// Interestingly enough, ECMAscript 5 also has\n// the \"search\" method which uses a regular\n// expression to determine if a string contains\n// a pattern. It also returns an index and suffers\n// from the same truthiness problem as \"indexOf\".\nconsole.log(s.search(/to/) > -1);\n\n// The \"contains\" method will accept a regular\n// expression, too.\nconsole.log(s.contains(/to/));\n\n// Why is that false? When we pass the regular\n// expression into \"contains\", it calls toString\n// on the regular expression which yields a\n// a serialized version of the regular expression\n// that contains the boundary delimeters.\nconsole.log(/to/.toString());\n\n// This means that \"contains\" actually searches\n// for the substring \"/to/\" in the string.\nconsole.log('here /to/ there'.contains(/to/));"
}
