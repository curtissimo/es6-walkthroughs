{
  "title": "String.prototype.normalize",
  "description": "Normalizing Unicode characters for search and comparison.",
  "code": "// I am not going to teach you about Unicode\n// equivalence and normalization. Because, OMG,\n// huge topic. However, I will show some examples\n// which will let you understand why this\n// \"normalize\" method now exists for strings.\n\n// Here's some Unicode. The \"IX\" is a single\n// Unicode character (U+2168), the superscript\n// 5 is a single Unicode character (U+2075),\n// and the ffi ligature mark (U+FB03) is a single\n// Unicode character.\nvar raw = \"ϔ Ⅸ⁵ = 59049 ﬃ\";\n\n// Now, Unicode describes four ways to\n// normalize values.\nvar nfc = raw.normalize('NFC');\nvar nfd = raw.normalize('NFD');\nvar nfkc = raw.normalize('NFKC');\nvar nfkd = raw.normalize('NFKD');\n\n// What do they do?\n// This one does essentially nothing. NFC\n// normalization will do nothing if you\n// start with well-formed Unicode.\nconsole.log(nfc, nfc.length, nfc.codePointAt(0));\n\n// This one decomposes the \"ϔ\" into two characters:\n// the \"ϒ\" and the combining umlaut character.\nconsole.log(nfd, nfd.length, nfd.codePointAt(0));\n\n// This one decomposes by compatibility, changing\n// the \"Ⅸ\" to \"IX\", the \"⁵\" to \"5\", the \"ﬃ\" to\n// \"ffi\", and the \"ϔ\" to \"Ϋ\"\nconsole.log(nfkc, nfkc.length, nfkc.codePointAt(0));\n\n// This one decomposes by compatibility and\n// combining characters, changing the \"ϔ\" into\n// \"Y\" and an umlaut, the \"Ⅸ\" to \"IX\", the \"⁵\"\n// to \"5\", and the \"ﬃ\" to \"ffi\".\nconsole.log(nfkd, nfkd.length, nfkd.codePointAt(0));\n"
}
